# Most bash completion scripts are wrong.
#
# They make assumptions based on current word and last word that are ofteh faulty.
# Eg a completion script determines the last word is `list`, and therefore assumes
# the user has entered a `list` subcommand ... but list might instead be the valid
# name of a file, database table, or other resource.
#
# There's only one way that I know of to reliably to bash completion: maintain the
# complete context for the current command.
#
# One straightfoward approach is to maintain context through the callstack. Command
# string tokens are parsed one by one, and every time a significant token is parsed,
# a function is called. The callstack therefore serves as the complete context
# necessary for proper completion. Each function isn't just aware of the current and
# previous. They also know all previous commands and tokens, since they were required
# to get to the function in the first place, provided each function is only reachable
# through a single call chain.
#
# This method requires writing many helper methods, each of which represents a 
# 'token chain'. Eg `on-config-get` handles the `get` subcommand of `config`. 
# `on-call-scriptPath` handles the `--script-path` flag of `call`. Hyphens are
# used to delimit tokens, so camelCase is used for flags and anything else
# containing a hyphen.
#
# bash completions should only be generated by a single function in the call chain.
# When on-config-get() generates completions and sets COMPREPLY, and control 
# returns to on-config(), it is important that on-config() does not overwrite
# COMPREPLY. This is the purpose of the DONE global variable. Any function that
# sets COMPREPLY can also set DONE to indicate that no subsequent function should
# attempt to set completions. Simply checking COMPREPLY would almost work, but 
# the empty array () is often a valid COMPREPLY value, and so it's more 
# straightforward to have a DONE variable explicitly control execution, instead
# of inferring it from COMPREPLY.

colorComment=$'\033[96m'
reset=$'\033[0m' 

# Set COMPREPLY to (), and set DONE
complete-with-empty () {
	COMPREPLY=()
	DONE=1
}

# Set COMPREPLY to files matched by the current token ($1), and set DONE
complete-with-files () {
	# shellcheck disable=SC2016
	(( $# == 1 )) || { printf 'Usage: complete-with-files $token\n' >&2; return 1; }
	local token=$1

	compopt -o filenames
	COMPREPLY=($(compgen -f -- "$token"))
	DONE=1
}

# Set COMPREPLY for the elements of a wordlist (#1) matched by the current 
# token ($2), and set DONE
complete-with-words () {
	# shellcheck disable=SC2016
	(( $# == 2 )) || { printf 'Usage: complete-with-words $wordlist $token\n' >&2; return 1; }
	local wordlist=$1
	local token=$2

	COMPREPLY=($(compgen -W "$wordlist" -- "$token"))
	DONE=1
}

# Get the next token from the command line, and increment N. The current
# token is just $COMP_WORDS indexed by N.
get-token () {
	local -n _ref=$1	
	_ref=${COMP_WORDS[N]}
	((N++))	
	printf '%-16s: token=%s N=%d\n' "get-token()" "$_ref" "$N" >> /tmp/dylt.log
}

# Check if the last token retrieved incremented N greater than the current word.
# If N is greated than COMP_CWORD, there are more no tokens left
# Typically this means `compgen` can be called on the in-progress token to generate completions
on-last-token () { 
	(( N > COMP_CWORD ))
}

# Get the next toke
peek-token () {
	local -n _ref=$1	
	_ref=${COMP_WORDS[N]}
	printf 'peek-token(): token=%s\n' "$_ref" >> /tmp/dylt.log
}

# Style text + print ANSI reset when done
comment () {
	printf '%s%s%s\n' "$colorComment" "$1" "$reset" >> /tmp/dylt.log
}

# Various bash completion values, global variables, etc. Useful for development/debugging.
status () {
	printf '%-16s: DONE=%d N=%d COMP_CWORD=%d cur=[%s] <%s>\n' "$1()" "$DONE" "$N" "$COMP_CWORD" "${COMP_WORDS[COMP_CWORD]}" "${COMP_WORDS[*]}" >> /tmp/dylt.log
}

# Entry point. Set global variables and call the main function
_f () {
	echo Initializing N >> /tmp/dylt.log
	N=1
	DONE=0
	status '_f'
	on-main
	printf '\n\n' >> /tmp/dylt.log
}

# Main function. 
on-main () {
	# flags + subcommands
	local cmds=(call config get host init list misc vm watch)
	local flags=()

	# get next token + print status
	get-token token
	status 'on-main'
		
	# get next token + print status
	get-token token
	status 'on-main'

	# If on last token, complete the cmd or flag
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		case $token in
			-*)	complete-with-words	"${flags[*]}"	"$token";	DONE;;
			*)	complete-with-words	"${cmds[*]}"	"$token";	DONE;;
		esac
		return
	fi
	
	# Handle subcommand
	comment "$(printf "Ready for what's next: token=%s\n" "$token")"
	case $token in
		call)	on-call;	status X-on-call ;;
		config)	on-config;	status X-on-config ;;
		get)	on-get;		status X-on-get ;;
		host)	on-host;	status X-on-host ;;
		init)	on-init;	status X-on-init ;;
		list)   on-list;	status X-on-list ;;
		misc)	on-misc;	status X-on-misc ;;
		vm)		on-vm;		status X-on-vm ;;
		watch)	on-watch;	status X-on-watch ;;
		*) COMPREPLY=(); DONE=1 ;;
	esac
			
	# Done
	comment "$(printf 'on-main() - done; last token=%s' "$token")"
}

on-call () {
	local cmds=(foo bar bum)     # fake subcommands for testing
	local flags=(--script-path)
	
	# get next token + print status
	get-token token
	status 'on-call'
	
	# If on last token, complete the cmd or flag
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		case $token in
			-*)	complete-with-words	"${flags[*]}"	"$token";	DONE;;
			*)	complete-with-words	"${cmds[*]}"	"$token";	DONE;;
		esac
		return
	fi

	# Call appropriate function for latest token
	comment "$(printf "Ready for what's next: token=%s\n" "$token")"
	case $token in
		--script-path) on-call-scriptPath; status X-on-c-sp;;
		*) COMPREPLY=() DONE=1;;
	esac
}

# f call --script-path /path/to/daylight.sh
on-call-scriptPath () {
	# get next token + print status
	get-token token
	status 'on-call-scriptPath'
	
	if on-last-token; then
		comment "$(printf 'current token is in progress (%s); set completions' "$token")" >> /tmp/dylt.log
		complete-with-files "$token"
		return
	fi	
	# Done
	comment "$(printf 'on-call-scriptPath() - done; last token=%s' "$token")"
}

on-config () {
	# flags + subcommands
	local cmds=(get set show)
	local flags=()

	# get next token + print status
	get-token token
	status 'on-config'

	# If on last token, complete the cmd or flag
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		case $token in
			-*)	complete-with-words	"${flags[*]}"	"$token";	DONE;;
			*)	complete-with-words	"${cmds[*]}"	"$token";	DONE;;
		esac
		return
	fi

	# Handle subcommand
	comment "$(printf 'Ready for next step (token=%s)\n' "$token")"
	case "$token" in
		get)  on-config-get;  status X-on-config-get;;
		set)  on-config-set;  status X-on-config-set;;
		show) on-config-show; status X-on-config-show;;
		*) complete-with-empty;;
	esac	

	 # Done
	comment "$(printf 'on-config() - done; last token=%s' "$token")"
}


on-config-get () {
	local argvals flags

	# config key
	argvals=(name age luckyNumber)
	flags=()
	get-token token
	status on-config-get-1
	if on-last-token; then
		comment "$(printf "we have arrived at the latest token; time to generate completions")"
		case $token in
			-*)	complete-with-words	"${flags[*]}"t"$token";;
			*)	complete-with-words	"${argsvals[*]}"t"$token";;
		esac
		return
	fi

	 # Done
	comment "$(printf 'config-get() - done; last token=%s' "$token")"
}


on-config-set () {
	local cmds=()
	local flags=()
	local keys=(name age luckyNumber)

	# first arg: config key
	get-token token
	status on-config-set-1
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		case $token in
			-*) complete-with-words "${flags[*]}" "$token";;
			*)  complete-with-words "${keys[*]}" "$token";;
		esac
		return
	fi
	
	# second arg: config value
	get-token token
	status on-config-set-2
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-empty
		return
	fi

	comment "$(printf 'config-set is complete; token=%s' "$token")"
}


on-config-show () {
	status on-config-show
	# this is a terminal state. we COMPREPLY=() and return
	complete-with-empty
}

on-get () {
	status on-get
	complete-with-empty
}


on-host () {
	cmds=(init)
	flags=()
	
	# subcmd
	get-token token
	status on-host
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		case $token in
			-*) complete-with-words "${flags[*]}" "$token";;
			*)  complete-with-words "${cmds[*]}" "$token";;
		esac
		return
	fi

	# there are tokens ahead, so switch on subcommand
	case "$token" in
		init) on-host-init; status X-on-host-init;;
		*)    complete-with-empty;;
	esac
}


on-host-init () {
	# first arg: uid (no help)
	get-token token
	status on-host-init-1
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-empty
		return
	fi
	
	# second arg: gid (no help)
	get-token token
	status on-host-init-2
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-empty
		return
	fi

	comment "$(printf 'on-host-init is complete; token=%s' "$token")"
}


on-init () {
	cmds=()
	flags=(--etcd-domain)
	
	# 1 - flag
	get-token token
	status on-init-1
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		case $token in
			-*) complete-with-words "${flags[*]}" "$token";;
			*)  complete-with-empty
		esac
		return
	fi

	# 2 - flag value (complete with empty)
	get-token token
	status on-init-2
	if on-last-token; then
		complete-with-empty
		return
	fi

	comment "$(printf 'on-init is complete; last token=%s' "$token")"
}

on-list () {
	status on-list
	# this is a terminal state. we COMPREPLY=() and return
	complete-with-empty
}

on-misc () {
	cmds=(create-two-node-cluster gen-etcd-run-script)
	flags=()
	
	# subcmd
	get-token token
	status on-misc
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		case $token in
			-*) complete-with-words "${flags[*]}" "$token";;
			*)  complete-with-words "${cmds[*]}" "$token";;
		esac
		return
	fi

	# go to correct subcommand handler
	case "$token" in 
		create-two-node-cluster) on-misc-createTwoNodeCluster; status X-on-misc-createTwoNodeCluster;;
		gen-etcd-run-script) on-misc-genEtcdRunScript; status X-on-misc-genEtcdRunScript;;
		*) comment "$(printf 'unrecognized subcommand: %s\n' "$token")";;
	esac

	comment "$(printf 'on-misc is complete; last token=%s' "$token")"
}


on-misc-createTwoNodeCluster () {
	status on-misc-createTwoNodeCluster
	complete-with-empty
}

on-misc-genEtcdRunScript () {
	status on-misc-genEtcdRunScript
	complete-with-empty
}


on-vm () {
	cmds=(add all del get list set)
	flags=()

	# subcommand
	get-token token
	status on-vm
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		case $token in
			-*) complete-with-words "${flags[*]}" "$token";;
			*)  complete-with-words "${cmds[*]}" "$token";;
		esac
		return
	fi

	# subcommand
	case "$token" in
		add)	on-vm-add;	status X-on-vm-add;;
		all)	on-vm-all;	status X-on-vm-all;;
		del)	on-vm-del;	status X-on-vm-del;;
		get)	on-vm-get;	status X-on-vm-get;;
		list)	on-vm-list;	status X-on-vm-list;;
		set)	on-vm-set;	status X-on-vm-set;;
		*) comment "$(printf 'unrecognized subcommand: %s\n' "$token")";;
	esac
	
	comment "$(printf 'on-misc is complete; last token=%s' "$token")"
}

on-vm-add () {
	# first arg: name (no help)
	get-token token
	status on-vm-add-1
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-empty
		return
	fi
	
	# second arg: fqdn (no help)
	get-token token
	status on-vm-add-2
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-empty
		return
	fi

	comment "$(printf 'on-vm-add is complete; last token=%s' "$token")"
}

on-vm-all () {
	status on-vm-all

	if on-last-token; then
		complete-with-empty
	fi
	
	comment "$(printf 'on-vm-all is complete; last token=%s' "$token")"
}

on-vm-del () {
	# first arg: name (no help)
	get-token token
	status on-vm-add-1
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-empty
		return
	fi
	
	comment "$(printf 'on-vm-del is complete; last token=%s' "$token")"
}

on-vm-get () {
	# first arg: name (no help)
	get-token token
	status on-vm-add-1
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-empty
		return
	fi
	
	comment "$(printf 'on-vm-get is complete; last token=%s' "$token")"
}

on-vm-list () {
	status on-vm-list
	if on-last-token; then
		complete-with-empty
	fi
	
	comment "$(printf 'on-vm-list is complete; last token=%s' "$token")"
}

on-vm-set () {
	# first arg - name (complete with empty)
	get-token token
	status on-vm-add-1
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-empty
		return
	fi

	# second arg - key (complete with words)
	keys=(foo bar bum)
	get-token token
	status on-vm-add-2
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-words "${keys[*]}" "$token"
		return
	fi

	# third arg - value (complete with empty
	get-token token
	status on-vm-add-3
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-empty
		return
	fi
	
	comment "$(printf 'on-vm-set is complete; last token=%s' "$token")"
}

on-watch () {
	cmds=(script svc)

	# subcommand
	get-token token
	status on-vm
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-words "${cmds[*]}" "$token"
		return
	fi

	case "$token" in
		script)	on-watch-script;	status X-on-watch-script;;
		svc)	on-watch-svc;		status X-on-watch-svc;;
		*) comment "$(printf 'unrecognized subcommand: %s\n' "$token")";;
	esac
	
	comment "$(printf 'on-watch is complete; last token=%s' "$token")"
}


on-watch-script () {
	# arg1 - script key (complete with empty)
	get-token token
	status on-watch-scr-1
	if on-last-token; then
		complete-with-empty
		return
	fi

	# arg2 - target path (complete with empty)
	get-token token
	status on-watch-scr-2
	if on-last-token; then
		complete-with-empty
		return
	fi

	comment "$(printf 'on-watch-script is complete; last token=%s' "$token")"
}

on-watch-svc () {
	# name (complete with empty)
	get-token token
	status on-watch-svc
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		complete-with-empty
		return
	fi
	
	comment "$(printf 'on-watch-svc is complete; last token=%s' "$token")"
}

complete -F _f f

###############################################################################
#
# SCRAPSSSSS
#
# 3 possiblities here
#   - --script-path has been entered, user is working on flagval    N=4 COMP_CWORD=3 cur=[/opt/bin/day] <f call --script-path /opt/bin/day>
#   - flagval is complete, user is ready to return back to command  N=4 COMP_CWORD=4 cur=[] <f call --script-path /opt/bin/daylight.sh >
#   - user has definitely moved on                                  N=4 COMP_CWORD=6 cur=[] <f call --script-path /opt/bin/daylight.sh /opt/bin/daylight.sh update-and-restart >


# on-foo () {
	# # We got here as a result of 3 possiblities
	# # - Ready for subcommand
	# # - Within flag
	# # - Within flagval
	# # A tricky edgecase is within a flagval, particularly when a flagval might be a valid subcommand. context/state is necessary
	# status 'on-foo'
	# cmds=(bar bum)
	# flags=(--value)
	# get-token token
	# local cur=${COMP_WORDS[COMP_CWORD]}
	# if [[ -z "$cur" ]]; then
		# cur=${COMP_WORDS[COMP_CWORD-1]}
	# fi
	# case $cur in
		# --value) on-foo-flag
			 # return;;
		# -*) COMPREPLY=($(compgen -W "${flags[*]}" -- "$cur"))
		    # return ;;
		# *) COMPREPLY=($(compgen -W "${cmds[*]}" -- "$cur"))
		   # return ;;
	# esac
# }

# on-foo-flag () {
	# status 'on-foo-flag'
	# get-token token
	# local cur=${COMP_WORDS[COMP_CWORD]}
		
# }

	# If we're here, the user has entered in the command name plus whitespace so that the
	# command has been tokenized.
	#
	# This means the next token is either in progress, or it isn't.
	# If it's in progress, then COMP_CWORD=N.
	# Else, the next token has been completed. We inspect it, and move on.
