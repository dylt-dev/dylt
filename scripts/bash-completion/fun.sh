# Most bash completion scripts are wrong.
#
# They make assumptions based on current word and last word that are ofteh faulty.
# Eg a completion script determines the last word is `list`, and therefore assumes
# the user has entered a `list` subcommand ... but list might instead be the valid
# name of a file, database table, or other resource.
#
# There's only one way that I know of to reliably to bash completion: maintain the
# complete context for the current command.
#
# One straightfoward approach is to maintain context through the callstack. Command
# string tokens are parsed one by one, and every time a significant token is parsed,
# a function is called. The callstack therefore serves as the complete context
# necessary for proper completion. Each function isn't just aware of the current and
# previous. They also know all previous commands and tokens, since they were required
# to get to the function in the first place, provided each function is only reachable
# through a single call chain.
#
# This method requires writing many helper methods, each of which represents a 
# 'token chain'. Eg `on-config-get` handles the `get` subcommand of `config`. 
# `on-call-scriptPath` handles the `--script-path` flag of `call`. Hyphens are
# used to delimit tokens, so camelCase is used for flags and anything else
# containing a hyphen.
#
# bash completions should only be generated by a single function in the call chain.
# When on-config-get() generates completions and sets COMPREPLY, and control 
# returns to on-config(), it is important that on-config() does not overwrite
# COMPREPLY. This is the purpose of the DONE global variable. Any function that
# sets COMPREPLY can also set DONE to indicate that no subsequent function should
# attempt to set completions. Simply checking COMPREPLY would almost work, but 
# the empty array () is often a valid COMPREPLY value, and so it's more 
# straightforward to have a DONE variable explicitly control execution, instead
# of inferring it from COMPREPLY.

colorComment=$'\033[96m'
reset=$'\033[0m' 

# Style text + print ANSI reset when done
comment () {
	printf '%s%s%s\n' "$colorComment" "$1" "$reset" >> /tmp/dylt.log
}

# Set COMPREPLY to (), and set DONE
complete-with-empty () {
	COMPREPLY=()
	DONE=1
}

# Set COMPREPLY to files matched by the current token ($1), and set DONE
complete-with-files () {
	# shellcheck disable=SC2016
	(( $# == 1 )) || { printf 'Usage: complete-with-files $token\n' >&2; return 1; }
	local token=$1

	compopt -o filenames
	COMPREPLY=($(compgen -f -- "$token"))
	DONE=1
}

# Set COMPREPLY for the elements of a wordlist (#1) matched by the current 
# token ($2), and set DONE
complete-with-words () {
	# shellcheck disable=SC2016
	(( $# == 2 )) || { printf 'Usage: complete-with-words $wordlist $token\n' >&2; return 1; }
	local wordlist=$1
	local token=$2

	COMPREPLY=($(compgen -W "$wordlist" -- "$token"))
	DONE=1
}

# Get the next token from the command line, and increment N. The current
# token is just $COMP_WORDS indexed by N.
get-token () {
	local -n _ref=$1	
	_ref=${COMP_WORDS[N]}
	((N++))	
	printf '%-16s: token=%s N=%d\n' "get-token()" "$_ref" "$N" >> /tmp/dylt.log
}

# Check if the last token retrieved incremented N greater than the current word.
# If N is greated than COMP_CWORD, there are more no tokens left
# Typically this means `compgen` can be called on the in-progress token to generate completions
on-last-token () { 
	(( N > COMP_CWORD ))
}

# Get the next toke
peek-token () {
	local -n _ref=$1	
	_ref=${COMP_WORDS[N]}
	printf 'peek-token(): token=%s\n' "$_ref" >> /tmp/dylt.log
}

# Various bash completion values, global variables, etc. Useful for development/debugging.
status () {
	printf '%-16s: DONE=%d N=%d COMP_CWORD=%d cur=[%s] <%s>\n' "$1()" "$DONE" "$N" "$COMP_CWORD" "${COMP_WORDS[COMP_CWORD]}" "${COMP_WORDS[*]}" >> /tmp/dylt.log
}

# Entry point. Set global variables and call the main function
_f () {
	echo Initializing N >> /tmp/dylt.log
	N=1
	DONE=0
	status '_f'
	on-main
	printf '\n\n' >> /tmp/dylt.log
}

# Main function. 
on-main () {
	# flags + subcommands
	local cmds=(call config get host init list misc vm watch)
	local flags=()

	get-token token
	status 'on-main'
	if on-last-token; then
		comment "$(printf "current token is in progress: no more looking")"
		case $token in
			-*)	complete-with-words	"${flags[*]}"	"$token";;
			*)	complete-with-words	"${cmds[*]}"	"$token";;
		esac
		return
	fi
	
	# Handle subcommand
	comment "$(printf "Ready for what's next: token=%s\n" "$token")"
	case $token in
		call)	on-call;	status X-on-call ;;
		config)	on-config;	status X-on-config ;;
		get)	on-get;		status X-on-get ;;
		host)	on-host;	status X-on-host ;;
		init)	on-init;	status X-on-init ;;
		list)   on-list;	status X-on-list ;;
		misc)	on-misc;	status X-on-misc ;;
		vm)		on-vm;		status X-on-vm ;;
		watch)	on-watch;	status X-on-watch ;;
		*) complete-with-empty
	esac
			
	# Done
	comment "$(printf 'on-main() - done; last token=%s' "$token")"
}

# on call [--flag flagval]
#
# @note valid functions + args for daylight.sh could be used for autocompletion
on-call () {
	local flags
	
	#  - complete with flags only
	flags=(--script-path)
	get-token token
	status on-call
	if on-last-token; then
		comment "$(printf "we have arrived at the latest token; time to generate completions")"
		case $token in
			-*) complete-with-words "${flags[*]}" "$token";;
			*)  complete-with-empty;;
		esac
		return
	fi

	# next token should be a flag. go to handler function, or complete with empty.
	case "$token" in
		--script-path)	on-call-scriptPath;	status X-on-c-sp;;
		*)	complete-with-empty;;
	esac
}


# dylt call --script-path /path/to/dylight.sh
#
# complete with files
on-call-scriptPath () {
	get-token token
	status on-call-scriptPath
	if on-last-token; then
		comment "$(printf "on latest token; complete with files")"
		complete-with-files "$token"
	fi

	# Done
	comment "$(printf 'on-call-scriptPath() - done; last token=%s' "$token")"
}


# dylt config subcommand
on-config () {
	# complete subcommand
	argvals=(get set show)
	get-token token
	status on-config
	if on-last-token; then
		comment 'generate completions for subcommand'
		case $token in
			*) complete-with-words "${argvals[*]}" "$token";;
		esac
		return
	fi

	# Handle subcommand
	comment "$(printf 'Ready for next step (token=%s)\n' "$token")"
	case "$token" in
		get)  on-config-get;  status X-on-config-get;;
		set)  on-config-set;  status X-on-config-set;;
		show) on-config-show; status X-on-config-show;;
		*) complete-with-empty;;
	esac	

	 # Done
	comment "$(printf 'on-config() - done; last token=%s' "$token")"
}


# dylt config get key
on-config-get () {
	local argvals

	# key - complete with argvals
	argvals=(name age luckyNumber)
	get-token token
	status on-config-get-1
	if on-last-token; then
		comment 'generate completions - argument values only'
		case $token in
			*) complete-with-words "${argvals[*]}";;
		esac
		return
	fi
	
	# Done
	comment "$(printf 'config-get() - done; last token=%s' "$token")"
}


# dylt config set key val
on-config-set () {
	local argvals

	# key - complete with argvals
	argvals=(name age luckyNumber)
	get-token token
	status on-config-set-1
	if on-last-token; then
		comment 'generate completions - argument values only'
		case "$token" in
			*) complete-with-words "${argvals[*]}" "$token";;
		esac
		return
	fi
	
	# val (complete with empty)
	get-token token
	status on-config-set-2
	if on-last-token; then
		comment 'handle latest token; complete with empty'
		complete-with-empty
		return
	fi

	# Done
	comment "$(printf 'on-config-set() - done; last token=%s' "$token")"
}


# on config show
#
# No completion help here
on-config-show () {
	status on-config-show
	complete-with-empty
}


# on get key
#
# No completion help here; key can be any value
# @note contraining `key` on valid cluster keys might be good
on-get () {
	status on-get
	complete-with-empty
}


# on host subcmd
on-host () {
	local argvals flags

	# complete subcommand
	argvals=(init)
	get-token token
	status 
	if on-last-token; then
		comment 'generate completions for subcommand'
		complete-with-words "${argvals[*]}" "$token"
		return
	fi
	
	# next token should be subcommand. go to handler function, or complete with empty.
	case "$token" in
		init) on-host-init; status X-on-host-init;;
		*)    complete-with-empty;;
	esac
}


# on host init uid gid
on-host-init () {
	# first arg: uid (complete with empty)
	get-token token
	status on-host-init-1
	if on-last-token; then
		comment "$(printf "we have arrived at the latest token; time to generate completions")"
		complete-with-empty
		return
	fi

	# second arg: gid (complete with empty)
	get-token token
	status on-host-init-2
	if on-last-token; then
		comment "$(printf "we have arrived at the latest token; time to generate completions")"
		complete-with-empty
		return
	fi

	 # Done
	comment "$(printf 'on-host-init() - done; last token=%s' "$token")"
}


# on init --etcd-domain etcd.cluster.domain
on-init () {
	# Next arg (if any) should be a flag; complete with flags only
	flags=(--etcd-domain)
	get-token token
	status on-init-1
	if on-last-token; then
		comment "$(printf "we have arrived at the latest token; time to generate completions")"
		case $token in
			-*) complete-with-words "${flags[*]}" "$token";;
			*)  complete-with-empty;;
		esac
		return
	fi

	# last token should have been a flag. go to handler function, or complete with empty.
	case "$token" in
		--etcd-domain)	on-init-etcdDomain;	status X-on-init-etcdDomain;;
		*)	complete-with-empty;;
	esac	
	
	 # Done
	comment "$(printf 'on-init() - done; last token=%s' "$token")"
}


# dylt init --etcd-domain etcd.cluster.domain
#
# Freeform - complete with empty
on-init-etcdDomain () {
	get-token token
	status on-init-etcdDomain
	if on-last-token; then
		comment "$(printf "on latest token; complete with empty")"
		complete-with-empty
	fi
}


# dylt list
#
# No completion help; complete with empty
on-list () {
	status on-list
	complete-with-empty
}


# on misc subcommand
on-misc () {
	# subcmd
	argvals=(create-two-node-cluster gen-etcd-run-script)
	flags=()
	get-token token
	status on-misc
	if on-last-token; then
		comment "$(printf "we have arrived at the latest token; time to generate completions")"
		case $token in
			-*)	complete-with-words	"${flags[*]}"	"$token";;
			*)	complete-with-words	"${argvals[*]}"	"$token";;
		esac
		return
	fi

	# next token should be subcommand. go to handler function, or complete with empty.
	case "$token" in 
		create-two-node-cluster)	on-misc-createTwoNodeCluster;	status X-on-misc-createTwoNodeCluster;;
		gen-etcd-run-script)		on-misc-genEtcdRunScript;		status X-on-genEtcdRunScript ;;
		*) comment "$(printf 'unrecognized subcommand: %s\n' "$token")"; complete-with-empty 
	esac

	comment "$(printf 'on-misc is complete; last token=%s' "$token")"
}


# dylt misc createTwoNodeCluster
#
# No args, no flags - complete with empty
on-misc-createTwoNodeCluster () {
	status on-misc-createTwoNodeCluster
	complete-with-empty
}


# dylt misc genEtcdRunScript
#
# No args, no flags - complete with empty
on-misc-genEtcdRunScript () {
	status on-misc-genEtcdRunScript
	complete-with-empty
}


# dylt vm subcommand
#
on-vm () {
	# First arg - subcommand, no flags
	argvals=(add all del get list set)
	get-token token
	status on-vm
	if on-last-token; then
		comment "$(printf "we have arrived at the latest token; time to generate completions")"
		case $token in
			*)	complete-with-words	"${argvals[*]}"	"$token";;
		esac
		return
	fi


	# Handle subcommand
	comment "$(printf 'Delegating to subcommand handler (token=%s)\n' "$token")"
	case "$token" in
		add)	on-vm-add;	status X-on-vm-add;;
		all)	on-vm-all;	status X-on-vm-all;;
		del)	on-vm-del;	status X-on-vm-del;;
		get)	on-vm-get;	status X-on-vm-get;;
		list)	on-vm-list;	status X-on-vm-list;;
		set)	on-vm-set;	status X-on-vm-set;;
		*) comment "$(printf 'unrecognized subcommand: %s\n' "$token")"; complete-with-empty ;;
	esac

	 # Done
	comment "$(printf 'on-vm() - done; last token=%s' "$token")"	
}


# dylt vm add name fqdn
on-vm-add () {
	# name (complete with empty)
	get-token token
	status on-vm-add-1
	if on-last-token; then
		comment 'handle latest token; complete with empty'
		complete-with-empty
		return
	fi

	# fqdn (complete with empty)
	get-token token
	status on-vm-add-2
	if on-last-token; then
		comment 'handle latest token; complete with empty'
		complete-with-empty
		return
	fi

	 # Done
	comment "$(printf 'on-vm-add() - done; last token=%s' "$token")"
}


# dylt on vm all
#
# No args, no flags - complete with empty
on-vm-all () {
	status on-vm-all
	complete-with-empty
}


# dylt vm del name
#
# @note - name could be autocompleted w existing vm names
on-vm-del () {
	# name (complete with empty)
	get-token token
	status on-vm-del-1
	if on-last-token; then
		comment 'handle latest token; complete with empty'
		complete-with-empty
		return
	fi

	 # Done
	comment "$(printf 'on-vm-del() - done; last token=%s' "$token")"	
}


# dylt vm get name
#
# @note - name could be autocompleted w existing vm names
on-vm-get () {
	# name (complete with empty)
	get-token token
	status on-vm-get-1
	if on-last-token; then
		comment 'handle latest token; complete with empty'
		complete-with-empty
		return
	fi

	 # Done
	comment "$(printf 'on-vm-get() - done; last token=%s' "$token")"	
}


# dylt vm list
#
# No args, no flags - complete with empty
on-vm-list () {
	status on-vm-list
	complete-with-empty
}


# dylt set name key val
#
# @note - name could be autocompleted w existing vm names
# @note - name could be autocompleted w fixed set of key names
on-vm-set () {
	# name (complete with empty)
	get-token token
	status on-vm-set-1
	if on-last-token; then
		comment 'handle latest token; complete with empty'
		complete-with-empty
		return
	fi

	# key (complete with empty)
	get-token token
	status on-vm-set-2
	if on-last-token; then
		comment 'handle latest token; complete with empty'
		complete-with-empty
		return
	fi

	# val (complete with empty)
	get-token token
	status on-vm-set-3
	if on-last-token; then
		comment 'handle latest token; complete with empty'
		complete-with-empty
		return
	fi

	 # Done
	comment "$(printf 'on-vm-set() - done; last token=%s' "$token")"	
}


# dylt watch subcommand
on-watch () {
	#  - complete with subcommands only
	argvals=(script svc)
	get-token token
	status on-watch-1
	if on-last-token; then
		comment "$(printf "we have arrived at the latest token; time to generate completions")"
		case $token in
			*) complete-with-words "${argvals[*]}";;
		esac
		return
	fi

	case "$token" in
		script)	on-watch-script;	status X-on-watch-script;;
		svc)	on-watch-svc;		status X-on-watch-svc;;
		*) comment "$(printf 'unrecognized subcommand: %s\n' "$token")";;
	esac
	
	 # Done
	comment "$(printf 'on-watch() - done; last token=%s' "$token")"
}


# dylt watch script key targetPath
on-watch-script () {
	# key (complete with empty)
	get-token token
	status on-watch-script-1
	if on-last-token; then
		comment 'handle latest token; complete with empty'
		complete-with-empty
		return
	fi

	# targetPath (complete with empty)
	get-token token
	status on-watch-script-2
	if on-last-token; then
		comment 'handle latest token; complete with empty'
		complete-with-empty
		return
	fi

	 # Done
	comment "$(printf 'on-watch-script() - done; last token=%s' "$token")"
}


# dylt watch svc name
#
# @note - name could be autocompleted w existing vm names
on-watch-svc () {
	# name (complete with empty)
	get-token token
	status on-watch-svc-1
	if on-last-token; then
		comment 'handle latest token; complete with empty'
		complete-with-empty
		return
	fi

	 # Done
	comment "$(printf 'on-watch-svc() - done; last token=%s' "$token")"
}


# Register completion handler with function
complete -F _f f



###############################################################################
#
# SCRAPSSSSS
#
# 3 possiblities here
#   - --script-path has been entered, user is working on flagval    N=4 COMP_CWORD=3 cur=[/opt/bin/day] <f call --script-path /opt/bin/day>
#   - flagval is complete, user is ready to return back to command  N=4 COMP_CWORD=4 cur=[] <f call --script-path /opt/bin/daylight.sh >
#   - user has definitely moved on                                  N=4 COMP_CWORD=6 cur=[] <f call --script-path /opt/bin/daylight.sh /opt/bin/daylight.sh update-and-restart >


# on-foo () {
	# # We got here as a result of 3 possiblities
	# # - Ready for subcommand
	# # - Within flag
	# # - Within flagval
	# # A tricky edgecase is within a flagval, particularly when a flagval might be a valid subcommand. context/state is necessary
	# status 'on-foo'
	# cmds=(bar bum)
	# flags=(--value)
	# get-token token
	# local cur=${COMP_WORDS[COMP_CWORD]}
	# if [[ -z "$cur" ]]; then
		# cur=${COMP_WORDS[COMP_CWORD-1]}
	# fi
	# case $cur in
		# --value) on-foo-flag
			 # return;;
		# -*) COMPREPLY=($(compgen -W "${flags[*]}" -- "$cur"))
		    # return ;;
		# *) COMPREPLY=($(compgen -W "${cmds[*]}" -- "$cur"))
		   # return ;;
	# esac
# }

# on-foo-flag () {
	# status 'on-foo-flag'
	# get-token token
	# local cur=${COMP_WORDS[COMP_CWORD]}
		
# }

	# If we're here, the user has entered in the command name plus whitespace so that the
	# command has been tokenized.
	#
	# This means the next token is either in progress, or it isn't.
	# If it's in progress, then COMP_CWORD=N.
	# Else, the next token has been completed. We inspect it, and move on.
